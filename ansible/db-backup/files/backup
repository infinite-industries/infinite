#!/bin/sh

set -o errexit

cd /home/infinite

IMAGE_TAG=${IMAGE_TAG:="master"}

# set DB_NAME to whatever is appropriate for this environment: use 
# the setting from the .env file
DB_NAME=$(grep -Po 'PGDATABASE=\K(.+)' docker-files/ops.env)

# directory on the host where backups are stored
HOST_BACKUP_DIR=/home/infinite/backups

# run an ephemeral ops container w/ env vars
OPS_RUN="docker run --rm \
  --env-file docker-files/ops.env \
  -v ${HOST_BACKUP_DIR}:/var/tmp/backups \
  ghcr.io/infinite-industries/ops-server:${IMAGE_TAG}"


# this function creates a "sanitized" dump- organizer_contatct email addresses
# are set to "nobody@example.com"
create_sanitized_dump() {
  
  # start a db container, initializing a scratch database with the latest sql
  # dump most of the commands below are executed in this cotnainer: note that
  # the backup dir is not mounted in this container.
  container=$(docker run -d \
    -u root \
    -v ${HOST_BACKUP_DIR}/$DB_NAME.sql.latest:/docker-entrypoint-initdb.d/init.sql \
    -e POSTGRES_PASSWORD=password -e PGHOST=localhost -e PGUSER=postgres \
    ghcr.io/infinite-industries/ops-server:backup-process)

  # when the script exits, remove the container that was just created.
  trap 'docker rm -f ${container} >/dev/null' INT TERM EXIT

  # the database in the container isn't ready immediately - block until it is
  docker exec ${container} \
    sh -c 'until pg_isready -q; do sleep 1 ; done;'

  # anonymize the organizer email address in the scratch database
  # note the redirection to stdout: otherwise this script will output superfluous info
  docker exec ${container} \
    psql -c "UPDATE events SET organizer_contact='nobody@example.com' WHERE true=true;" \
    >/dev/null

  # dump the sanitized scratch database
  docker exec ${container} \
    pg_dump -Fc --no-owner --no-acl > ${HOST_BACKUP_DIR}/$DB_NAME.sanitized.latest

  # create an SQL dump
  # unlike other commands in this function, this command executes on the host
  # system, NOT the scratch container.
  ${OPS_RUN} sh -c 'pg_restore --no-owner --no-acl \
    -f - /var/tmp/backups/${PGDATABASE}.sanitized.latest \
    > /var/tmp/backups/${PGDATABASE}.sanitized.sql.latest'

}

#
# MAIN SCRIPT 
#

# create dumpfile
${OPS_RUN} sh -c 'pg_dump -d "sslmode=require" -Fc -f /var/tmp/backups/${PGDATABASE}.latest'

# create sql dump
${OPS_RUN} sh -c 'pg_restore --no-owner --no-acl -f - /var/tmp/backups/${PGDATABASE}.latest \
  > /var/tmp/backups/${PGDATABASE}.sql.latest'

# create sanitized versions of the above
create_sanitized_dump

# backup primary dump file to a dated S3 object
${OPS_RUN} env suffix=$(date +%Y-%m-%d) sh -c \
  'aws s3 cp /var/tmp/backups/${PGDATABASE}.latest \
    s3://${S3_BUCKET}/${S3_PATH}/${PGDATABASE}.latest.${suffix}' \
  >/dev/null

# backup the various latest files
for suffix in latest sanitized.latest sanitized.sql.latest; do
    ${OPS_RUN} env suffix=${suffix} sh -c \
      'aws s3 cp /var/tmp/backups/${PGDATABASE}.${suffix} \
        s3://${S3_BUCKET}/${S3_PATH}/${PGDATABASE}.${suffix}' \
      >/dev/null
done

